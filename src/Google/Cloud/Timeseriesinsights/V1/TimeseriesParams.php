<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/cloud/timeseriesinsights/v1/timeseries_insights.proto

namespace Google\Cloud\Timeseriesinsights\V1;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Parameters that control how we construct the time series for each slice.
 *
 * Generated from protobuf message <code>google.cloud.timeseriesinsights.v1.TimeseriesParams</code>
 */
class TimeseriesParams extends \Google\Protobuf\Internal\Message
{
    /**
     * Required. How long should we go in the past when fetching the timeline used for
     * forecasting each slice.
     * This is used in combination with the
     * [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] parameter.
     * The time series we construct will have the following time range:
     * `[detectionTime - forecastHistory, detectionTime + granularity]`.
     * The forecast history might be rounded up, so that a multiple of
     * `granularity` is used to process the query.
     * Note: If there are not enough events in the
     * `[detectionTime - forecastHistory, detectionTime + granularity]` time
     * interval, the slice evaluation can fail. For more information, see
     * [EvaluatedSlice.status][google.cloud.timeseriesinsights.v1.EvaluatedSlice.status].
     *
     * Generated from protobuf field <code>.google.protobuf.Duration forecast_history = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    protected $forecast_history = null;
    /**
     * Required. The time granularity of the time series (on the x-axis). Each time series
     * point starting at time T will aggregate all events for a particular slice
     * in *[T, T + granularity)* time windows.
     * Note: The aggregation is decided based on the
     * [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] parameter.
     * This granularity defines the query-time aggregation windows and is not
     * necessarily related to any event time granularity in the raw data (though
     * we do recommend that the query-time granularity is not finer than the
     * ingestion-time one).
     * Currently, the minimal supported granularity is 10 seconds.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration granularity = 2 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    protected $granularity = null;
    /**
     * Optional. Denotes the [name][google.cloud.timeseriesinsights.v1.EventDimension.name] of a numerical
     * dimension that will have its values aggregated to compute the y-axis of the
     * time series.
     * The aggregation method must also be specified by setting the
     * [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
     * field.
     * Note: Currently, if the aggregation method is unspecified, we will
     * default to SUM for backward compatibility reasons, but new implementations
     * should set the
     * [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
     * explicitly.
     * If the metric is unspecified, we will use the number of events that each
     * time series point contains as the point value.
     * Example: Let's assume we have the following three events in our dataset:
     * ```json
     * {
     *   eventTime: "2020-12-27T00:00:00Z",
     *   dimensions: [
     *     { name: "d1" stringVal: "v1" },
     *     { name: "d2" stringVal: "v2" }
     *     { name: "m1" longVal: 100 }
     *     { name: "m2" longVal: 11 }
     *   ]
     * },
     * {
     *   eventTime: "2020-12-27T00:10:00Z",
     *   dimensions: [
     *     { name: "d1" stringVal: "v1" },
     *     { name: "d2" stringVal: "v2" }
     *     { name: "m1" longVal: 200 }
     *     { name: "m2" longVal: 22 }
     *   ]
     * },
     * {
     *   eventTime: "2020-12-27T00:20:00Z",
     *   dimensions: [
     *     { name: "d1" stringVal: "v1" },
     *     { name: "d2" stringVal: "v2" }
     *     { name: "m1" longVal: 300 }
     *     { name: "m2" longVal: 33 }
     *   ]
     * }
     * ```
     * These events are all within the same hour, spaced 10 minutes between each
     * of them. Assuming our [QueryDataSetRequest][google.cloud.timeseriesinsights.v1.QueryDataSetRequest] had set
     * [slicingParams.dimensionNames][google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names] to ["d1",
     * "d2"] and [timeseries_params.granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] to
     * "3600s", then all the previous events will be aggregated into the same
     * [timeseries point][google.cloud.timeseriesinsights.v1.TimeseriesPoint].
     * The time series point that they're all part of will have the
     * [time][google.cloud.timeseriesinsights.v1.TimeseriesPoint.time] set to "2020-12-27T00:00:00Z" and the
     * [value][google.cloud.timeseriesinsights.v1.TimeseriesPoint.value] populated based on this metric field:
     * - If the metric is set to "m1" and metric_aggregation_method to SUM, then
     * the value of the point will be 600.
     * - If the metric is set to "m2" and metric_aggregation_method to SUM, then
     * the value of the point will be 66.
     * - If the metric is set to "m1" and metric_aggregation_method to AVERAGE,
     * then the value of the point will be 200.
     * - If the metric is set to "m2" and metric_aggregation_method to AVERAGE,
     * then the value of the point will be 22.
     * - If the metric field is "" or unspecified, then the value of the point
     * will be 3, as we will simply count the events.
     *
     * Generated from protobuf field <code>optional string metric = 4 [(.google.api.field_behavior) = OPTIONAL];</code>
     */
    protected $metric = null;
    /**
     * Optional. Together with the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] field, specifies how
     * we will aggregate multiple events to obtain the value of a time series
     * point. See the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] documentation for more
     * details.
     * If the metric is not specified or "", then this field will be ignored.
     *
     * Generated from protobuf field <code>.google.cloud.timeseriesinsights.v1.TimeseriesParams.AggregationMethod metric_aggregation_method = 5 [(.google.api.field_behavior) = OPTIONAL];</code>
     */
    protected $metric_aggregation_method = 0;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Google\Protobuf\Duration $forecast_history
     *           Required. How long should we go in the past when fetching the timeline used for
     *           forecasting each slice.
     *           This is used in combination with the
     *           [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] parameter.
     *           The time series we construct will have the following time range:
     *           `[detectionTime - forecastHistory, detectionTime + granularity]`.
     *           The forecast history might be rounded up, so that a multiple of
     *           `granularity` is used to process the query.
     *           Note: If there are not enough events in the
     *           `[detectionTime - forecastHistory, detectionTime + granularity]` time
     *           interval, the slice evaluation can fail. For more information, see
     *           [EvaluatedSlice.status][google.cloud.timeseriesinsights.v1.EvaluatedSlice.status].
     *     @type \Google\Protobuf\Duration $granularity
     *           Required. The time granularity of the time series (on the x-axis). Each time series
     *           point starting at time T will aggregate all events for a particular slice
     *           in *[T, T + granularity)* time windows.
     *           Note: The aggregation is decided based on the
     *           [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] parameter.
     *           This granularity defines the query-time aggregation windows and is not
     *           necessarily related to any event time granularity in the raw data (though
     *           we do recommend that the query-time granularity is not finer than the
     *           ingestion-time one).
     *           Currently, the minimal supported granularity is 10 seconds.
     *     @type string $metric
     *           Optional. Denotes the [name][google.cloud.timeseriesinsights.v1.EventDimension.name] of a numerical
     *           dimension that will have its values aggregated to compute the y-axis of the
     *           time series.
     *           The aggregation method must also be specified by setting the
     *           [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
     *           field.
     *           Note: Currently, if the aggregation method is unspecified, we will
     *           default to SUM for backward compatibility reasons, but new implementations
     *           should set the
     *           [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
     *           explicitly.
     *           If the metric is unspecified, we will use the number of events that each
     *           time series point contains as the point value.
     *           Example: Let's assume we have the following three events in our dataset:
     *           ```json
     *           {
     *             eventTime: "2020-12-27T00:00:00Z",
     *             dimensions: [
     *               { name: "d1" stringVal: "v1" },
     *               { name: "d2" stringVal: "v2" }
     *               { name: "m1" longVal: 100 }
     *               { name: "m2" longVal: 11 }
     *             ]
     *           },
     *           {
     *             eventTime: "2020-12-27T00:10:00Z",
     *             dimensions: [
     *               { name: "d1" stringVal: "v1" },
     *               { name: "d2" stringVal: "v2" }
     *               { name: "m1" longVal: 200 }
     *               { name: "m2" longVal: 22 }
     *             ]
     *           },
     *           {
     *             eventTime: "2020-12-27T00:20:00Z",
     *             dimensions: [
     *               { name: "d1" stringVal: "v1" },
     *               { name: "d2" stringVal: "v2" }
     *               { name: "m1" longVal: 300 }
     *               { name: "m2" longVal: 33 }
     *             ]
     *           }
     *           ```
     *           These events are all within the same hour, spaced 10 minutes between each
     *           of them. Assuming our [QueryDataSetRequest][google.cloud.timeseriesinsights.v1.QueryDataSetRequest] had set
     *           [slicingParams.dimensionNames][google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names] to ["d1",
     *           "d2"] and [timeseries_params.granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] to
     *           "3600s", then all the previous events will be aggregated into the same
     *           [timeseries point][google.cloud.timeseriesinsights.v1.TimeseriesPoint].
     *           The time series point that they're all part of will have the
     *           [time][google.cloud.timeseriesinsights.v1.TimeseriesPoint.time] set to "2020-12-27T00:00:00Z" and the
     *           [value][google.cloud.timeseriesinsights.v1.TimeseriesPoint.value] populated based on this metric field:
     *           - If the metric is set to "m1" and metric_aggregation_method to SUM, then
     *           the value of the point will be 600.
     *           - If the metric is set to "m2" and metric_aggregation_method to SUM, then
     *           the value of the point will be 66.
     *           - If the metric is set to "m1" and metric_aggregation_method to AVERAGE,
     *           then the value of the point will be 200.
     *           - If the metric is set to "m2" and metric_aggregation_method to AVERAGE,
     *           then the value of the point will be 22.
     *           - If the metric field is "" or unspecified, then the value of the point
     *           will be 3, as we will simply count the events.
     *     @type int $metric_aggregation_method
     *           Optional. Together with the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] field, specifies how
     *           we will aggregate multiple events to obtain the value of a time series
     *           point. See the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] documentation for more
     *           details.
     *           If the metric is not specified or "", then this field will be ignored.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Google\Cloud\Timeseriesinsights\V1\TimeseriesInsights::initOnce();
        parent::__construct($data);
    }

    /**
     * Required. How long should we go in the past when fetching the timeline used for
     * forecasting each slice.
     * This is used in combination with the
     * [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] parameter.
     * The time series we construct will have the following time range:
     * `[detectionTime - forecastHistory, detectionTime + granularity]`.
     * The forecast history might be rounded up, so that a multiple of
     * `granularity` is used to process the query.
     * Note: If there are not enough events in the
     * `[detectionTime - forecastHistory, detectionTime + granularity]` time
     * interval, the slice evaluation can fail. For more information, see
     * [EvaluatedSlice.status][google.cloud.timeseriesinsights.v1.EvaluatedSlice.status].
     *
     * Generated from protobuf field <code>.google.protobuf.Duration forecast_history = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return \Google\Protobuf\Duration|null
     */
    public function getForecastHistory()
    {
        return $this->forecast_history;
    }

    public function hasForecastHistory()
    {
        return isset($this->forecast_history);
    }

    public function clearForecastHistory()
    {
        unset($this->forecast_history);
    }

    /**
     * Required. How long should we go in the past when fetching the timeline used for
     * forecasting each slice.
     * This is used in combination with the
     * [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] parameter.
     * The time series we construct will have the following time range:
     * `[detectionTime - forecastHistory, detectionTime + granularity]`.
     * The forecast history might be rounded up, so that a multiple of
     * `granularity` is used to process the query.
     * Note: If there are not enough events in the
     * `[detectionTime - forecastHistory, detectionTime + granularity]` time
     * interval, the slice evaluation can fail. For more information, see
     * [EvaluatedSlice.status][google.cloud.timeseriesinsights.v1.EvaluatedSlice.status].
     *
     * Generated from protobuf field <code>.google.protobuf.Duration forecast_history = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param \Google\Protobuf\Duration $var
     * @return $this
     */
    public function setForecastHistory($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Duration::class);
        $this->forecast_history = $var;

        return $this;
    }

    /**
     * Required. The time granularity of the time series (on the x-axis). Each time series
     * point starting at time T will aggregate all events for a particular slice
     * in *[T, T + granularity)* time windows.
     * Note: The aggregation is decided based on the
     * [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] parameter.
     * This granularity defines the query-time aggregation windows and is not
     * necessarily related to any event time granularity in the raw data (though
     * we do recommend that the query-time granularity is not finer than the
     * ingestion-time one).
     * Currently, the minimal supported granularity is 10 seconds.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration granularity = 2 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return \Google\Protobuf\Duration|null
     */
    public function getGranularity()
    {
        return $this->granularity;
    }

    public function hasGranularity()
    {
        return isset($this->granularity);
    }

    public function clearGranularity()
    {
        unset($this->granularity);
    }

    /**
     * Required. The time granularity of the time series (on the x-axis). Each time series
     * point starting at time T will aggregate all events for a particular slice
     * in *[T, T + granularity)* time windows.
     * Note: The aggregation is decided based on the
     * [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] parameter.
     * This granularity defines the query-time aggregation windows and is not
     * necessarily related to any event time granularity in the raw data (though
     * we do recommend that the query-time granularity is not finer than the
     * ingestion-time one).
     * Currently, the minimal supported granularity is 10 seconds.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration granularity = 2 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param \Google\Protobuf\Duration $var
     * @return $this
     */
    public function setGranularity($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Duration::class);
        $this->granularity = $var;

        return $this;
    }

    /**
     * Optional. Denotes the [name][google.cloud.timeseriesinsights.v1.EventDimension.name] of a numerical
     * dimension that will have its values aggregated to compute the y-axis of the
     * time series.
     * The aggregation method must also be specified by setting the
     * [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
     * field.
     * Note: Currently, if the aggregation method is unspecified, we will
     * default to SUM for backward compatibility reasons, but new implementations
     * should set the
     * [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
     * explicitly.
     * If the metric is unspecified, we will use the number of events that each
     * time series point contains as the point value.
     * Example: Let's assume we have the following three events in our dataset:
     * ```json
     * {
     *   eventTime: "2020-12-27T00:00:00Z",
     *   dimensions: [
     *     { name: "d1" stringVal: "v1" },
     *     { name: "d2" stringVal: "v2" }
     *     { name: "m1" longVal: 100 }
     *     { name: "m2" longVal: 11 }
     *   ]
     * },
     * {
     *   eventTime: "2020-12-27T00:10:00Z",
     *   dimensions: [
     *     { name: "d1" stringVal: "v1" },
     *     { name: "d2" stringVal: "v2" }
     *     { name: "m1" longVal: 200 }
     *     { name: "m2" longVal: 22 }
     *   ]
     * },
     * {
     *   eventTime: "2020-12-27T00:20:00Z",
     *   dimensions: [
     *     { name: "d1" stringVal: "v1" },
     *     { name: "d2" stringVal: "v2" }
     *     { name: "m1" longVal: 300 }
     *     { name: "m2" longVal: 33 }
     *   ]
     * }
     * ```
     * These events are all within the same hour, spaced 10 minutes between each
     * of them. Assuming our [QueryDataSetRequest][google.cloud.timeseriesinsights.v1.QueryDataSetRequest] had set
     * [slicingParams.dimensionNames][google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names] to ["d1",
     * "d2"] and [timeseries_params.granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] to
     * "3600s", then all the previous events will be aggregated into the same
     * [timeseries point][google.cloud.timeseriesinsights.v1.TimeseriesPoint].
     * The time series point that they're all part of will have the
     * [time][google.cloud.timeseriesinsights.v1.TimeseriesPoint.time] set to "2020-12-27T00:00:00Z" and the
     * [value][google.cloud.timeseriesinsights.v1.TimeseriesPoint.value] populated based on this metric field:
     * - If the metric is set to "m1" and metric_aggregation_method to SUM, then
     * the value of the point will be 600.
     * - If the metric is set to "m2" and metric_aggregation_method to SUM, then
     * the value of the point will be 66.
     * - If the metric is set to "m1" and metric_aggregation_method to AVERAGE,
     * then the value of the point will be 200.
     * - If the metric is set to "m2" and metric_aggregation_method to AVERAGE,
     * then the value of the point will be 22.
     * - If the metric field is "" or unspecified, then the value of the point
     * will be 3, as we will simply count the events.
     *
     * Generated from protobuf field <code>optional string metric = 4 [(.google.api.field_behavior) = OPTIONAL];</code>
     * @return string
     */
    public function getMetric()
    {
        return isset($this->metric) ? $this->metric : '';
    }

    public function hasMetric()
    {
        return isset($this->metric);
    }

    public function clearMetric()
    {
        unset($this->metric);
    }

    /**
     * Optional. Denotes the [name][google.cloud.timeseriesinsights.v1.EventDimension.name] of a numerical
     * dimension that will have its values aggregated to compute the y-axis of the
     * time series.
     * The aggregation method must also be specified by setting the
     * [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
     * field.
     * Note: Currently, if the aggregation method is unspecified, we will
     * default to SUM for backward compatibility reasons, but new implementations
     * should set the
     * [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
     * explicitly.
     * If the metric is unspecified, we will use the number of events that each
     * time series point contains as the point value.
     * Example: Let's assume we have the following three events in our dataset:
     * ```json
     * {
     *   eventTime: "2020-12-27T00:00:00Z",
     *   dimensions: [
     *     { name: "d1" stringVal: "v1" },
     *     { name: "d2" stringVal: "v2" }
     *     { name: "m1" longVal: 100 }
     *     { name: "m2" longVal: 11 }
     *   ]
     * },
     * {
     *   eventTime: "2020-12-27T00:10:00Z",
     *   dimensions: [
     *     { name: "d1" stringVal: "v1" },
     *     { name: "d2" stringVal: "v2" }
     *     { name: "m1" longVal: 200 }
     *     { name: "m2" longVal: 22 }
     *   ]
     * },
     * {
     *   eventTime: "2020-12-27T00:20:00Z",
     *   dimensions: [
     *     { name: "d1" stringVal: "v1" },
     *     { name: "d2" stringVal: "v2" }
     *     { name: "m1" longVal: 300 }
     *     { name: "m2" longVal: 33 }
     *   ]
     * }
     * ```
     * These events are all within the same hour, spaced 10 minutes between each
     * of them. Assuming our [QueryDataSetRequest][google.cloud.timeseriesinsights.v1.QueryDataSetRequest] had set
     * [slicingParams.dimensionNames][google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names] to ["d1",
     * "d2"] and [timeseries_params.granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] to
     * "3600s", then all the previous events will be aggregated into the same
     * [timeseries point][google.cloud.timeseriesinsights.v1.TimeseriesPoint].
     * The time series point that they're all part of will have the
     * [time][google.cloud.timeseriesinsights.v1.TimeseriesPoint.time] set to "2020-12-27T00:00:00Z" and the
     * [value][google.cloud.timeseriesinsights.v1.TimeseriesPoint.value] populated based on this metric field:
     * - If the metric is set to "m1" and metric_aggregation_method to SUM, then
     * the value of the point will be 600.
     * - If the metric is set to "m2" and metric_aggregation_method to SUM, then
     * the value of the point will be 66.
     * - If the metric is set to "m1" and metric_aggregation_method to AVERAGE,
     * then the value of the point will be 200.
     * - If the metric is set to "m2" and metric_aggregation_method to AVERAGE,
     * then the value of the point will be 22.
     * - If the metric field is "" or unspecified, then the value of the point
     * will be 3, as we will simply count the events.
     *
     * Generated from protobuf field <code>optional string metric = 4 [(.google.api.field_behavior) = OPTIONAL];</code>
     * @param string $var
     * @return $this
     */
    public function setMetric($var)
    {
        GPBUtil::checkString($var, True);
        $this->metric = $var;

        return $this;
    }

    /**
     * Optional. Together with the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] field, specifies how
     * we will aggregate multiple events to obtain the value of a time series
     * point. See the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] documentation for more
     * details.
     * If the metric is not specified or "", then this field will be ignored.
     *
     * Generated from protobuf field <code>.google.cloud.timeseriesinsights.v1.TimeseriesParams.AggregationMethod metric_aggregation_method = 5 [(.google.api.field_behavior) = OPTIONAL];</code>
     * @return int
     */
    public function getMetricAggregationMethod()
    {
        return $this->metric_aggregation_method;
    }

    /**
     * Optional. Together with the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] field, specifies how
     * we will aggregate multiple events to obtain the value of a time series
     * point. See the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] documentation for more
     * details.
     * If the metric is not specified or "", then this field will be ignored.
     *
     * Generated from protobuf field <code>.google.cloud.timeseriesinsights.v1.TimeseriesParams.AggregationMethod metric_aggregation_method = 5 [(.google.api.field_behavior) = OPTIONAL];</code>
     * @param int $var
     * @return $this
     */
    public function setMetricAggregationMethod($var)
    {
        GPBUtil::checkEnum($var, \Google\Cloud\Timeseriesinsights\V1\TimeseriesParams\AggregationMethod::class);
        $this->metric_aggregation_method = $var;

        return $this;
    }

}

